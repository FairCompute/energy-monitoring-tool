<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Scheduling & Energy Attribution</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
    <style>
        body {
            font-family: "Inter", sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2f7 100%); /* Light, calming background */
            padding: 1.5rem;
            color: #374151; /* Default text color */
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* Rounded corners */
            box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.15); /* Soft shadow */
            padding: 2.5rem;
            max-width: 1000px; /* Wider for better visualization */
            width: 100%;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            border: 1px solid rgba(0, 0, 0, 0.03); /* Very subtle border */
        }
        h1 {
            color: #1a202c; /* Darker heading */
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 1rem;
        }
        h2 {
            color: #2d3748; /* Sub-heading color */
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        p {
            font-size: 1.125rem;
            line-height: 1.7;
            margin-bottom: 1rem;
        }
        canvas {
            background-color: #e2e8f0; /* Light gray for canvas background */
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
            width: 100%; /* Make canvas responsive */
            height: 150px; /* Fixed height for the timeline, made a bit shorter */
            display: block;
            margin: 0 auto;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 600;
            color: #4a5568;
        }
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 0.25rem;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .explanation-section {
            background-color: #f7fafc;
            border-radius: 1rem;
            padding: 1.5rem;
            text-align: left;
            box-shadow: 0 5px 10px rgba(0,0,0,0.05);
            border: 1px solid #edf2f7;
        }
        .explanation-section h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2c5282;
            margin-bottom: 0.75rem;
        }
        .explanation-section p {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 0.5rem;
        }
        .key-term {
            font-weight: 700;
            color: #2b6cb0; /* Stronger blue for key terms */
        }
        .diagram-container {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px dashed #cbd5e0;
        }
        .diagram-container:first-of-type {
            border-top: none; /* No border for the very first diagram */
        }

        /* Styles for the bar chart and pie chart */
        .chart-container {
            width: 100%;
            height: 250px;
            position: relative;
            margin: 0 auto;
            background-color: #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* Separate style for pie chart container */
        .pie-chart-container {
            width: 100%;
            height: 300px; /* Increased from 250px */
            position: relative;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: visible; /* Changed from hidden to allow labels to overflow */
            background-color: transparent;
        }

        .pie-chart-container canvas {
            background-color: transparent;
            box-shadow: none;
            width: 100%;
            height: 100%;
        }
        
        .bar-chart-bars {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            width: 80%;
            height: 80%;
            padding: 1rem;
        }
        .bar-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }
        .bar-label {
            width: 120px; /* Adjusted width for longer label */
            text-align: right;
            font-weight: 600;
            color: #4a5568;
        }
        .bar-fill {
            height: 26px;
            border-radius: 0.25rem;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 0.5rem;
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 1.5rem;
                gap: 1.5rem;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            p {
                font-size: 1rem;
            }
            .explanation-section h3 {
                font-size: 1.25rem;
            }
            .explanation-section p {
                font-size: 0.9rem;
            }
            .bar-chart-bars {
                width: 95%; /* Adjust width for smaller screens */
            }
            .bar-label {
                width: 90px; /* Adjusted width for smaller screens */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Process Scheduling & Energy Attribution</h1>

        <!-- Diagram 1: Simplified CPU Activity Timeline -->
        <div class="explanation-section diagram-container">
            <h2>1. CPU Activity Timeline: Time Slicing & Context Switching</h2>
            <p>A CPU rapidly switches between processes, giving each a small "time slice" to execute. The brief pauses between slices are "context switches," where the CPU saves one process's state and loads another's. Note that time slices can vary in duration based on operating system scheduling decisions and process needs.</p>
            <canvas id="cpuTimelineCanvas"></canvas>
            <div class="flex flex-wrap justify-center gap-4 mt-4">
                <div class="legend-item">
                    <div class="color-box bg-blue-500"></div>
                    <span>Process A</span>
                </div>
                <div class="legend-item">
                    <div class="color-box bg-green-500"></div>
                    <span>Process B</span>
                </div>
                <div class="legend-item">
                    <div class="color-box bg-purple-500"></div>
                    <span>Process C</span>
                </div>
                <div class="legend-item">
                    <div class="color-box bg-orange-500"></div>
                    <span>Idle Process</span>
                </div>
                <div class="legend-item">
                    <div class="color-box bg-gray-400"></div>
                    <span>Context Switch</span>
                </div>
            </div>
        </div>

        <!-- Diagram 2: Accumulated CPU Time & % Utilization -->
        <div class="explanation-section diagram-container">
            <h2>2. Accumulated CPU Time & CPU Utilization (%)</h2>
            <p>Over a period, each process accumulates "CPU time" â€“ the total time it spent actively running. This accumulated time, relative to the total available time, determines its CPU utilization percentage. The remaining time is categorized as "System Overhead," which includes both true idle periods and the time spent on context switching.</p>
            <div class="chart-container">
                <div class="bar-chart-bars">
                    <div class="bar-item">
                        <span class="bar-label">Process A:</span>
                        <div id="cpu-util-bar-A" class="bar-fill" style="background-color: #3b82f6;"></div>
                    </div>
                    <div class="bar-item">
                        <span class="bar-label">Process B:</span>
                        <div id="cpu-util-bar-B" class="bar-fill" style="background-color: #22c55e;"></div>
                    </div>
                    <div class="bar-item">
                        <span class="bar-label">Process C:</span>
                        <div id="cpu-util-bar-C" class="bar-fill" style="background-color: #a855f7;"></div>
                    </div>
                    <div class="bar-item">
                        <span class="bar-label">Idle Process:</span>
                        <div id="cpu-util-bar-D" class="bar-fill" style="background-color: #f97316;"></div>
                    </div>
                    <div class="bar-item">
                        <span class="bar-label">System Overhead:</span>
                        <div id="cpu-util-bar-Idle" class="bar-fill" style="background-color: #9ca3af;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Combined Diagram 3: Proportional Energy Attribution -->
        <div class="explanation-section diagram-container">
            <h2>3. Proportional Energy Attribution</h2>
            <p>EMT attributes energy consumption by first normalizing the resource utilization of active processes and then proportionally distributing the total measured energy.</p>

            <div class="flex flex-col md:flex-row gap-6 mt-6">
                <!-- Sub-section 1: Relative CPU Utilization Among Active Processes -->
                <div class="explanation-section flex-1">
                    <h3>3a. Relative CPU Utilization Among Active Processes</h3>
                    <p>The CPU time of active processes (A, B, C) is normalized relative to their combined total. This effectively distributes any non-attributable CPU time (like idle periods or general system overhead not directly tied to a specific process) among the active processes.</p>
                    <div class="pie-chart-container">
                        <canvas id="relativeUtilizationPieChart"></canvas>
                    </div>
                    <div class="flex flex-wrap justify-center gap-4 mt-2">
                        <!-- Change mt-4 to mt-2 ^^^ -->
                        <div class="legend-item">
                            <div class="color-box bg-blue-500"></div>
                            <span>Process A</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box bg-green-500"></div>
                            <span>Process B</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box bg-purple-500"></div>
                            <span>Process C</span>
                        </div>
                    </div>
                    <p class="mt-4 text-center font-semibold text-blue-700">
                    $$ \text{Norm. Util. (P)} = \left(\frac{\text{P's CPU Time}}{\text{CPU Time of All Active Processes}}\right) \times 100\% $$
                    </p>
                </div>

                <!-- Sub-section 2: Proportional Energy Attribution to Active Processes -->
                <div class="explanation-section flex-1">
                    <h3>3b. Proportional Energy Attribution to Active Processes</h3>
                    <p class="mb-6">Using the normalized utilization percentages from above, the total energy consumed by the core (e.g., 500 Joules) is proportionally attributed to each active process.</p>
                    <br><br><br>
                    <div class="chart-container">
                        <div class="bar-chart-bars">
                            <div class="bar-item">
                                <span class="bar-label">Process A:</span>
                                <div id="energy-attr-bar-A" class="bar-fill" style="background-color: #3b82f6;"></div>
                            </div>
                            <div class="bar-item">
                                <span class="bar-label">Process B:</span>
                                <div id="energy-attr-bar-B" class="bar-fill" style="background-color: #22c55e;"></div>
                            </div>
                            <div class="bar-item">
                                <span class="bar-label">Process C:</span>
                                <div id="energy-attr-bar-C" class="bar-fill" style="background-color: #a855f7;"></div>
                            </div>
                        </div>
                    </div>
                    <p class="mt-4 text-center font-semibold text-blue-700">
                        $$ \text{Energy}^\text{P} =\text{Norm. Util. (P)} \times \text{Total Measured Energy (Joules)} $$
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Diagram 1: CPU Activity Timeline ---
        const timelineCanvas = document.getElementById('cpuTimelineCanvas');
        const timelineCtx = timelineCanvas.getContext('2d');

        const timelineProcesses = [
            { id: 'A', color: '#3b82f6' },   // Blue
            { id: 'B', color: '#22c55e' },   // Green
            { id: 'C', color: '#a855f7' },   // Purple
            { id: 'D', color: '#f97316' }    // Orange - Idle Process
        ];

        const contextSwitchMatrix = {
            'A': { 'B': 8, 'C': 7, 'D': 8 },    // Reduced from ~15 to ~8
            'B': { 'A': 8, 'C': 7, 'D': 8 },
            'C': { 'A': 7, 'B': 7, 'D': 7 },
            'D': { 'A': 8, 'B': 8, 'C': 7 }
        };

        const minTimeSliceDuration = 20;         // Increased from 5 to 20
        const maxTimeSliceDuration = 80;         // Increased from 60 to 80
        const totalSimulationTime = 1000; // Total time to simulate for the bar
        const segmentHeight = 40; // Height of each segment in the timeline
        const padding = 10; // Padding around the timeline

        let currentX = padding; // Current drawing position on the canvas for timeline

        // Function to draw a segment on the timeline canvas
        function drawTimelineSegment(processColor, duration, isContextSwitch = false) {
            const canvasWidth = timelineCanvas.width;
            const segmentWidth = (duration / totalSimulationTime) * (canvasWidth - 2 * padding);

            timelineCtx.fillStyle = processColor;
            timelineCtx.fillRect(currentX, padding, segmentWidth, segmentHeight);

            // Add text for process ID if it's not a context switch and segment is wide enough
            if (!isContextSwitch && segmentWidth > 20) {
                timelineCtx.fillStyle = 'white';
                timelineCtx.font = 'bold 12px Inter';
                timelineCtx.textAlign = 'center';
                timelineCtx.textBaseline = 'middle';
                const process = timelineProcesses.find(p => p.color === processColor);
                if (process) {
                    timelineCtx.fillText(
                        process.id === 'D' ? 'Idle' : `P${process.id}`,
                        currentX + segmentWidth / 2,
                        padding + segmentHeight / 2
                    );
                }
            }

            currentX += segmentWidth; // Move drawing position
        }

        // Add before simulateTimeline function
        let processExecutionTimes = {
            'A': 0,
            'B': 0,
            'C': 0,
            'D': 0
        };

        function getContextSwitchTime(fromProcess, toProcess) {
            return contextSwitchMatrix[fromProcess][toProcess];
        }

        // Function to simulate and draw the CPU timeline
        function simulateTimeline() {
            // Reset execution times for new simulation
            processExecutionTimes = {
                'A': 0,
                'B': 0,
                'C': 0,
                'D': 0
            };

            timelineCtx.clearRect(0, 0, timelineCanvas.width, timelineCanvas.height);
            currentX = padding;

            let simulatedTime = 0;
            let processIndex = 0;

            // Loop until the total simulation time is reached
            while (simulatedTime < totalSimulationTime) {
                const currentProcess = timelineProcesses[processIndex];
                const nextProcessIndex = (processIndex + 1) % timelineProcesses.length;
                const nextProcess = timelineProcesses[nextProcessIndex];

                // Generate a random time slice duration within the defined range
                const randomTimeSlice = Math.floor(Math.random() * (maxTimeSliceDuration - minTimeSliceDuration + 1)) + minTimeSliceDuration;
                const executionTime = Math.min(randomTimeSlice, totalSimulationTime - simulatedTime);

                if (executionTime > 0) {
                    drawTimelineSegment(currentProcess.color, executionTime);
                    // Track execution time for this process
                    processExecutionTimes[currentProcess.id] += executionTime;
                    simulatedTime += executionTime;
                }

                // Update context switch logic
                if (simulatedTime < totalSimulationTime) {
                    const switchTime = getContextSwitchTime(currentProcess.id, nextProcess.id);
                    const overheadTime = Math.min(switchTime, totalSimulationTime - simulatedTime);
                    if (overheadTime > 0) {
                        drawTimelineSegment('#9ca3af', overheadTime, true);
                        simulatedTime += overheadTime;
                    }
                }

                processIndex = nextProcessIndex;

                // Stop if we've drawn past the total simulation time
                if (currentX >= timelineCanvas.width - padding) break;
            }

            // Update accumulated times based on simulation
            accumulatedProcesses.forEach(process => {
                process.accumulatedTime = processExecutionTimes[process.id];
            });
            
            // Render the updated CPU utilization
            renderAccumulatedCPU();

            // Draw a border around the entire timeline for clarity
            timelineCtx.strokeStyle = '#64748b';
            timelineCtx.lineWidth = 2;
            timelineCtx.strokeRect(padding, padding, timelineCanvas.width - 2 * padding, segmentHeight);
        }

        // Set timeline canvas dimensions based on its display size for responsiveness
        function resizeTimelineCanvas() {
            timelineCanvas.width = timelineCanvas.offsetWidth;
            timelineCanvas.height = timelineCanvas.offsetHeight;
            simulateTimeline(); // Redraw on resize
        }


        // --- Diagram 2: Accumulated CPU Time & % Utilization ---
        const accumulatedProcesses = [
            { id: 'A', accumulatedTime: 300, color: '#3b82f6' }, // Increased accumulated time
            { id: 'B', accumulatedTime: 280, color: '#22c55e' }, // Adjusted for more realistic overhead
            { id: 'C', accumulatedTime: 220, color: '#a855f7' },
            { id: 'D', accumulatedTime: 100, color: '#f97316' }
        ];
        const totalPeriodTime = 1000; // Example total time period

        function renderAccumulatedCPU() {
            const totalCpuTimeUsed = accumulatedProcesses.reduce((sum, p) => sum + p.accumulatedTime, 0);
            const systemOverheadTime = totalPeriodTime - totalCpuTimeUsed;

            // Get references to the bar elements
            const cpuUtilBarA = document.getElementById('cpu-util-bar-A');
            const cpuUtilBarB = document.getElementById('cpu-util-bar-B');
            const cpuUtilBarC = document.getElementById('cpu-util-bar-C');
            const cpuUtilBarD = document.getElementById('cpu-util-bar-D');
            const cpuUtilBarOverhead = document.getElementById('cpu-util-bar-Idle'); // Renamed ID for clarity

            // Calculate utilization percentages
            const utilA = (accumulatedProcesses[0].accumulatedTime / totalPeriodTime) * 100;
            const utilB = (accumulatedProcesses[1].accumulatedTime / totalPeriodTime) * 100;
            const utilC = (accumulatedProcesses[2].accumulatedTime / totalPeriodTime) * 100;
            const utilD = (accumulatedProcesses[3].accumulatedTime / totalPeriodTime) * 100;
            const utilOverhead = (systemOverheadTime / totalPeriodTime) * 100;

            // Update bar widths and text content
            cpuUtilBarA.style.width = `${utilA}%`;
            cpuUtilBarA.textContent = `Process A: ${utilA.toFixed(1)}%`;
            cpuUtilBarB.style.width = `${utilB}%`;
            cpuUtilBarB.textContent = `Process B: ${utilB.toFixed(1)}%`;
            cpuUtilBarC.style.width = `${utilC}%`;
            cpuUtilBarC.textContent = `Process C: ${utilC.toFixed(1)}%`;
            cpuUtilBarD.style.width = `${utilD}%`;
            cpuUtilBarD.textContent = `Idle Process: ${utilD.toFixed(1)}%`;
            cpuUtilBarOverhead.style.width = `${utilOverhead}%`;
            cpuUtilBarOverhead.textContent = `System Overhead: ${utilOverhead.toFixed(1)}%`;
        }


        // --- Section 3: Proportional Energy Attribution ---
        const activeProcesses = [
            { id: 'A', accumulatedTime: 300, color: '#3b82f6' },
            { id: 'B', accumulatedTime: 280, color: '#22c55e' },
            { id: 'C', accumulatedTime: 220, color: '#a855f7' }
        ];

        const totalEnergyJoules = 500; // Total energy in Joules

        function drawPieChart(canvasId, data) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.7;

            let currentAngle = 0;
            const total = data.reduce((sum, item) => sum + item.value, 0);

            data.forEach(item => {
                const sliceAngle = (item.value / total) * 2 * Math.PI;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                ctx.closePath();
                ctx.fillStyle = item.color;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Add labels
                const midAngle = currentAngle + sliceAngle / 2;
                const textX = centerX + radius * 0.65 * Math.cos(midAngle);
                const textY = centerY + radius * 0.65 * Math.sin(midAngle);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 3;
                ctx.fillText(`${(item.percentage).toFixed(1)}%`, textX, textY);
                ctx.shadowBlur = 0;

                currentAngle += sliceAngle;
            });
        }

        function renderEnergyAttribution() {
            const totalActiveTime = activeProcesses.reduce((sum, p) => sum + p.accumulatedTime, 0);

            // Calculate normalized utilization and energy attribution
            const processData = activeProcesses.map(process => {
                const normalizedUtil = (process.accumulatedTime / totalActiveTime) * 100;
                const energyShare = (normalizedUtil / 100) * totalEnergyJoules;
                return {
                    ...process,
                    normalizedUtil,
                    energyShare
                };
            });

            // Update relative utilization pie chart
            drawPieChart('relativeUtilizationPieChart', processData.map(p => ({
                value: p.normalizedUtil,
                color: p.color,
                percentage: p.normalizedUtil
            })));

            // Update energy attribution bars
            processData.forEach(process => {
                const bar = document.getElementById(`energy-attr-bar-${process.id}`);
                if (bar) {
                    bar.style.width = `${process.normalizedUtil}%`;
                    bar.textContent = `${process.energyShare.toFixed(1)} Joules (${process.normalizedUtil.toFixed(1)}%)`;
                }
            });
        }

        // --- Initialize all visualizations ---
        window.onload = function() {
            resizeTimelineCanvas();
            renderAccumulatedCPU();
            renderEnergyAttribution();

            window.addEventListener('resize', () => {
                resizeTimelineCanvas();
                renderEnergyAttribution();
            });
        };
    </script>
</body>
</html>
